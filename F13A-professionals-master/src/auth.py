'''
Auth.py contains all of the functions relevant to the user registering an account
as well as logging in/out. It imports the global data structure from data.py to
store/access information.
'''

import string
import smtplib
from random import randint, choice
import data
from error import AccessError, InputError

def auth_login(email, password):
    '''
    Accepts an email and password from a user, and after checking that the email is valid
    and exists in the datastructure, as well as the password matching, it returns their user ID
    and a new token.
    '''
    temp_data = data.getData()
    if not data.check_email_valid(email):
        raise InputError(description='Invalid Email Address')

    if email not in data.get_email_list():
        raise InputError(description='Email Address does not belong to a user')

    if not check_password_match(email, password, temp_data):
        raise InputError(description='Password is not correct')
    users_id = get_u_id(email, temp_data)
    new_token = data.generate_token(users_id)

    return {
        'token': new_token,
        'u_id': users_id,
    }

def auth_logout(token):
    '''
    Accepts a token, and after checkign that it is valid, it invalidates the token and returns
    True on success (False otherwise).
    '''
    if not data.check_valid_token(token):
        raise AccessError()

    data.invalidate_token(token)

    return {
        'is_success': True,
    }

def auth_register(email, password, name_first, name_last):
    '''
    Accepts a set of user details, and after checking that they are all valid data inputs,
    generates a unique handle, a new u_id and a new token. It adds all of these points of
    data to a new dictionary in the list of users, and then returns the ID and token.
    '''
    if not data.check_email_valid(email):
        raise InputError(description='Invalid Email Address')

    if not check_unique_email(email):
        raise InputError(description='Email Address Already Registered')

    if not check_valid_password(password):
        raise InputError(description='Invalid Password')

    if not check_valid_name(name_first):
        raise InputError(description='Invalid First Name')

    if not check_valid_name(name_last):
        raise InputError(description='Invalid Last Name')

    handle = generate_handle(name_first, name_last)
    new_id = generate_id()
    new_token = data.generate_token(new_id)
    data.add_new_user(email, password, name_first, name_last, handle, new_id, new_token)

    return {
        'u_id': new_id,
        'token': new_token,
    }

def generate_handle(name_first, name_last):
    '''
    Generates a handle as specified in the spec, with a 20 character concatenation of the first
    and last names. If the handle is taken, it changes a randomly selected character in the string
    to a random ascii letter until the handle is unique. Returns this unique handle.
    '''
    handle = list(name_first + name_last)
    if len(handle) > 20:
        handle = handle[:19]

    while not check_unique_handle(handle):
        random_num = randint(0, 19)
        handle[random_num] = choice(string.ascii_letters)

    return "".join(handle)

def check_unique_handle(handle):
    '''
    Checks whether an inputted handle exists already in the list of users in the datastructure.
    returns False if the handle is not unique, True otherwise.
    '''
    flag = True
    handle_list = data.get_handle_list()
    if handle in handle_list:
        flag = False
    return flag

def check_valid_name(name):
    '''
    Returns true if an inputted name adheres to the valid character limits, False if it doesn't.
    '''
    if str(name) == "" or len(name) > 50:
        return False
    return True

def generate_id():
    '''
    returns a unique user Id that doesn't exist in the list of users. ID is generated by assigning
    new ID's to be the number of users in the systems, and iterates until it is unique.
    '''
    u_id_list = data.get_u_id_list()
    new_id = len(u_id_list)
    while new_id in u_id_list:
        new_id += 1
    return new_id

def check_unique_email(email):
    '''
    Returns False if a given email is in the list of users, and True otherwise.
    '''
    flag = True
    email_list = data.get_email_list()
    if email in email_list:
        flag = False
    return flag

def check_valid_password(password):
    '''
    Returns False if a given password is below the specified character limit. True otherwise.
    '''
    if len(password) < 6:
        return False
    return True

def check_password_match(email, password, temp_data):
    '''
    Returns Ture if, for an email present in the datastructure, a given password matches what is
    stored in that users information. Returns False otherwise.
    '''
    flag = False
    for user in temp_data['users']:
        if user['email'] == email and user['password'] == password:
            flag = True
    return flag

def get_u_id(email, temp_data):
    '''
    Returns the u_id attached to a particular users email. If the email can't be found in
    the system, it returns None.
    '''
    for user in temp_data['users']:
        if user['email'] == email:
            return user['u_id']
    return None

def set_code(email, new_code, temp_data):
    '''
    sets a users reset code in the live data structure to the given new_code
    '''
    for user in temp_data['users']:
        if user['email'] == email:
            user['reset_code'] = new_code

def password_reset_request(request_email):
    '''
    Checks if the given email belongs to a registered user and sends them an email containing
    a reset code for their password.
    '''
    temp_data = data.getData()
    if check_unique_email(request_email):
        raise InputError(description='Email Does Not Belong To A Registered User.')

    new_code = 'reset' + str(randint(0, 9999))
    while check_valid_code(new_code, temp_data):
        new_code = 'reset' + str(randint(0, 9999))
    temp_data = data.getData()
    server = smtplib.SMTP('smtp.gmail.com', 587)
    server.connect("smtp.gmail.com", 587)
    server.starttls()
    server.login("1531pythonprofessional@gmail.com", "T1login@unsw")
    message = "Your password reset code for your Slackr account is " + str(new_code)
    server.sendmail("1531pythonprofessional@gmail.com", request_email, message)
    set_code(request_email, new_code, temp_data)
    server.quit()

def set_new_password(temp_data, reset_code, new_password):
    '''
    Given a valid reset_code, updates a users passwords and sets their reset_code to None.
    '''
    for user in temp_data['users']:
        if user['reset_code'] == reset_code:
            user['password'] = new_password
            user['reset_code'] = None

def check_valid_code(code, temp_data):
    '''
    checks if a given reset_code is valid i.e. a user in the data structure has been provided
    that same code.
    '''
    if code is None:
        return False
    for user in temp_data['users']:
        if user['reset_code'] == code:
            return True
    return False


def password_reset(reset_code, new_password):
    '''
    Checks for a valid password and a valid reset code, and then updates the password for a user.
    '''
    temp_data = data.getData()

    if not check_valid_code(reset_code, temp_data):
        raise InputError(description='Invalid Reset Code')
    if not check_valid_password(new_password):
        raise InputError(description='Invalid Password')

    set_new_password(temp_data, reset_code, new_password)
